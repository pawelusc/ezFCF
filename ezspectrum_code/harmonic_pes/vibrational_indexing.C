#include "vibrational_indexing.h"

//! get a next vibrational state (norm_modes -- number of normal modes, max_excitations -- totoal max number of vibr quanta in all normal modes)
bool enumerateVibrStates(int norm_modes, int max_excitations, std::vector <int>& state, const bool if_comb_bands)

  // (to initialize (generate first population of the vibrational states) make state[0] negative)
  //
  // Example:
  // norm_modes=5, max_excitations=7;  "state"=[2,1,3,0,1] ("see stars and bars" problem)
  // "state" contains number of "stars" (excitations for each normal mode) in each bin [2,1,3,0,1]: **|*|***||*
  // "combination" contains position of the "bars" (in modified set -- plus one star in each bin) [2,4,8,9]:***|**|****|*|**
  // this util. (1)converts "state"->"combination" 
  //            (2)calculates the next "combination" using enumerateCombinations(n,k,comb) (ennumerates combinations, total number = C_n^k)
  //            (3)converts "combination"->"state"

{
  bool tmp_return;

  if ((if_comb_bands)and(norm_modes>1)) //include combination bands && not a single normal moe (no combintaion bands than)
    {
      std::vector <int> combination;
      for (int i=0; i<max_excitations+norm_modes-1; i++)
	combination.push_back(-1);
      
      // "state" -> "combination"
      int curr_combination = 0;
      int total_vibrations = 0;
      if (  !(state[0]<0)  ) // (if not the first call)
	for (int i=0; i<state.size()-1; i++) 
	  {
	    total_vibrations += state[i]+1;
	    combination[curr_combination] = total_vibrations-1;
	    curr_combination++;
	  }

      // calculate the next "combination":
      tmp_return = enumerateCombinations(max_excitations+norm_modes-1, norm_modes-1, combination);
      
      // "combination"->"state"
      state[0] = combination[0];

      for (int i=1; i<(norm_modes-1); i++)
	state[i]=combination[i]-combination[i-1]-1;
      state[norm_modes-1]=max_excitations-(combination[norm_modes-2]-(norm_modes-1)+1);
    }

  else // do not include combination bands
    {
      if (state[0]<0) // first call --> initialize
	{
	  for (int i=0; i<norm_modes-1; i++)
	    state[i] = 0;
	  state[norm_modes-1] = max_excitations;
	  tmp_return = true;
	}
      else
	{
	  if ((max_excitations == 0) or (state[0]>0)) // (only |0,0,0, > ground state) OR (last index)
	    tmp_return = false; 
	  else
	  {
	    for (int i=1; i<norm_modes; i++)
	      {
		if (state[i]>0) 
		  {
		    state[i-1]=state[i];
		    state[i]=0;
		  }
	      }
	    tmp_return = true;
	  }
	}
    }

  //TMP=== print the state:
  //  for (int j=0; j<state.size()-1; j++)
  //    std::cout << state[j] << ',';
  //std::cout << state[state.size()-1] << " = STATE\n";

  return tmp_return;
}

//! returns tbe position of the "state" in the list of states generated by enumerateVibrStates() iterator function (for a given total number of excitations and number of normal modes)
// ZZZ 4/11/2012 removed, and the combinations are calculated now on the fly
//unsigned long convVibrState2Index(std::vector <int>& state, int N, unsigned long * C, int k)
unsigned long convVibrState2Index(std::vector <int>& state, int N, int k)
  // state -- vector with quantum numbers; length N; K--total maximum number of excitations (summ of all elements)
  // starts from the left "digit"=state[0]; calculates how many states of length (N-1) with (K-state[0]) exists = C_([N-1]-1)^([K-state[0]]+[N-1]-1)
  // goes recursively though all "digist" down the list
{
  unsigned long number=0;
  for (int i=0, n=N-1; i<N-1; i++, n--)
    {
      int alpha;
      
      for (alpha=0; alpha<state[i]; alpha++)
	{
	  // ZZZ 4/11/2012 removed, and the combinations are calculated now on the fly
	  //  number+=C[(k-alpha+n-1)*N+(n-1)];//==Combination(k-alpha+n-1, n-1)
	  // std::cout << k-alpha+n-1 << " " << n-1 << "\n";
	  number+=Combination( k-alpha+n-1 , n-1 );
	}
      k-=alpha;
    }
  return number;
}

void convIndex2VibrState(unsigned long index, std::vector <int>& state)
{
  std::cout << "\n\nDEBUG. Function convIndex2VibrState() is not implemented yet. Use enumerateVibrStates() iterator for now.\n\n";
  exit(2);
}


